<% # print a header unless there is no disaggregation %>
<% if subset.disagg_value != :all %>
  <% value_str = subset.disagg_value ? subset.disagg_value.name : "[#{t('common.blank')}]" %>
  <h2><%= "#{@report.disagg_qing.question.code}: #{value_str}"%></h2>
  <small><%= t("report/report.subset_intro", {disagg_value: value_str, question: @report.disagg_qing.question.code}) %></small>
<% end %>

<div class="subset <%= subset.disagg_value == "all" ? "" : "disaggregated" %> <%= subset.group_by_tag ? "group_by_tag" : "" %>">

  <% # if no data, then print a notice %>

  <% if subset.no_data? %>

    <em><%= t("report/report.no_match") %></em>

  <% else %>

    <% subset.tag_groups.each do |tag_group| %>
      <% Rails.logger.debug("TAG GROUP *******") %>
      <% Rails.logger.debug(tag_group.tag) %>

      <% # print tag header if grouped by tag %>
      <% if subset.group_by_tag %>
        <div class="tag-header">
          <% if tag_group.tag == "untagged" %>
            <h3 class="untagged">Untagged questions</h3>
          <% else %>
            <h3>Questions tagged <span class="token-input-token-elmo"><%= tag_group.tag.name %></span></h3>
          <% end %>
        </div>
      <% end %>

      <% tag_group.type_groups.each do |group| %>

        <% # determine the number of result columns in the table %>
        <% result_cols = [8, group.max_header_count].min %>

        <% # show group header unless there is only one big group %>
        <% if group.type_set != "all" %>
          <h3><%= t("report/report.standard_form_report.type_sets.#{group.type_set}") %></h3>
        <% end %>

        <table class="subset result_cols_<%= result_cols %>">

          <% group.clusters.each do |cluster|%>

            <% # do cluster header row %>
            <tr class="cluster_header">
              <td></td>

              <% # if full width display type with responses, header cell must be extra wide %>
              <td <%= cluster.display_type == "full_width" ? "colspan='#{result_cols + 1}'" : ""%>
                &nbsp;
              </td>

              <% # do rest of header cells if necessary %>
              <% if cluster.display_type == "flow" || cluster.display_type == "structured" && cluster.headers.length > result_cols %>
                <td colspan="<%= result_cols %>"><%= cluster.overall_header %></td>

              <% elsif cluster.display_type == "structured" %>
                <% # print out each header cell %>
                <% cluster.headers.each do |header| %>
                  <td class="structured"><%= render(partial: "reports/standard_form_report/form_summary_header", locals: {header: header}) %></td>
                <% end %>

                <% # print out blank cell to fill up to max %>
                <% if result_cols > cluster.headers.length %>
                  <td colspan="<%= result_cols - cluster.headers.length %>"></td>
                <% end %>
              <% end %>
            </tr>

            <% # do summary rows %>
            <% cluster.summaries.each do |summary| %>

              <% # if this is a full_width summary, it gets multiple rows, one item per row %>
              <% if cluster.display_type == "full_width" %>

                <tr class="summary full_width_subhead">
                  <td class="num">#<%= summary.questioning.full_dotted_rank %></td>
                  <td colspan="<%= result_cols + 2 %>">
                    <%= render(partial: "reports/standard_form_report/form_summary_question_label", locals: {summary: summary}) %>
                  </td>
                </tr>

                <%# if no items, show the 'no data' message %>
                <% if summary.items.length == 0 %>

                  <tr class="summary">
                    <td colspan="<%= result_cols + 2 %>">
                      <em class="no_match"><%= I18n.t('report/report.no_match') %></em>
                    </td>
                  </tr>

                <%# otherwise, loop over each item (answer) and make a row for it %>
                <% else %>

                  <% summary.items.each do |item| %>
                    <tr class="summary">
                      <td colspan="<%= result_cols + 2 %>">
                        <%= render(partial: "reports/standard_form_report/form_summary_item", locals: {item: item}) %>
                      </td>
                    </tr>
                  <% end %>

                <% end %>

              <% else %>

                <tr class="summary">
                  <td class="num">#<%= summary.questioning.full_dotted_rank %></td>
                  <td class="qname">
                    <%= render(partial: "reports/standard_form_report/form_summary_question_label", locals: {summary: summary}) %>
                  </td>

                  <% # if flow type, or if any other type and items are empty, just print the responses sep'd by commas %>
                  <% if cluster.display_type == 'flow' || summary.items.length == 0 %>

                    <td colspan="<%= result_cols %>">
                      <% if summary.items.length == 0 %>
                        <em class="no_match"><%= t("report/report.no_match") %></em>
                      <% end %>

                      <%= summary.items.map{|item| "#{item.text}"}.join(", ") %>
                    </td>

                  <% # if structured type with less than result_cols, do separate cells %>
                  <% elsif cluster.display_type == 'structured' && cluster.headers.length <= result_cols %>

                    <% summary.items.each do |item| %>
                      <td class="structured"><%= render(partial: "reports/standard_form_report/form_summary_item", locals: {item: item}) %></td>
                    <% end %>

                    <% # print out blank cell to fill up to max %>
                    <% if result_cols > cluster.headers.length %>
                      <td colspan="<%= result_cols - cluster.headers.length %>"></td>
                    <% end %>

                  <% # if structured type with more than result_cols, do one big cell %>
                  <% elsif cluster.display_type == "structured" && cluster.headers.length > result_cols %>

                    <td colspan="<%= result_cols %>">
                      <%= summary.items.each_with_index.map{|item, idx| render(partial: "reports/standard_form_report/form_summary_item_with_header", locals: {item: item, header: cluster.headers[idx]}) }.join(", ") %>
                    </td>

                    <% # print out blank cell to fill up to max %>
                    <% if result_cols > cluster.headers.length %>
                      <td colspan="<%= result_cols - cluster.headers.length %>"></td>
                    <% end %>

                  <% end %>
                </tr>
              <% end %>
            <% end %>
          <% end %>
        </table>
      <% end %>
    <% end %>
  <% end %>
</div>
